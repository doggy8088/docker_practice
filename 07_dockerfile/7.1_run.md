## 7.1 RUN 執行指令

### 基本語法

具體內容如下：

```docker
RUN <command>
RUN ["executable", "param1", "param2"]
```

`RUN` 指令是 Dockerfile 中最常用的指令之一。它在**當前映象層**之上建立一個新層，執行指定的指令，並送出結果。

---

### 兩種格式對比

#### 1. Shell 格式

具體內容如下：

```docker
RUN apt-get update
```

- **特點**：預設透過 `/bin/sh -c` 執行。
- **優勢**：可以使用環境變數、通道、重導向等 Shell 屬性。
- **範例**：
  ```docker
  RUN echo "Hello" > /test.txt
  ```

#### 2. Exec 格式

具體內容如下：

```docker
RUN ["apt-get", "update"]
```

- **特點**：直接呼叫可執行檔案，不經過 Shell。
- **優勢**：避免 Shell 字串解析問題，適用於引數中包含特殊字元的情況。
- **注意**：無法使用 `$VAR` 環境變數替換（除非顯式呼叫 shell）。

---

### 常見最佳實踐

#### 1. 組合指令（減少層數）

每一個 `RUN` 指令都會新建一層映象。為了減少映象體積和層數，應使用 `&&` 連線指令。

**❌ 糟糕的寫法**（建立 3 層）：

```docker
RUN apt-get update
RUN apt-get install -y nginx
RUN rm -rf /var/lib/apt/lists/*
```

**✅ 推薦寫法**（建立 1 層）：

```docker
RUN apt-get update && \
    apt-get install -y nginx && \
    rm -rf /var/lib/apt/lists/*
```

#### 2. 清理快取

在安裝完軟體後，立即清除快取，可以顯著減小映象體積。

- **Debian/Ubuntu**:
  ```docker
  RUN apt-get update && apt-get install -y package-bar \
      && rm -rf /var/lib/apt/lists/*
  ```
- **Alpine**:
  ```docker
  RUN apk add --no-cache package-bar
  ```

#### 3. 使用 `set -e` 和 `pipefail`

預設情況下，通道指令 `cmd1 | cmd2` 只要 `cmd2` 成功，整個 `RUN` 就視為成功。

**❌ 隱蔽的錯誤**：

```docker
## 如果下載失敗，gzip 可能會報錯，但如果不影響後續，建立可能繼續

RUN wget http://error-url | gzip -d > file
```

**✅ 推薦寫法**：

```docker
SHELL ["/bin/bash", "-o", "pipefail", "-c"]
RUN wget http://url | gzip -d > file
```

---

### 常見問題

#### Q: 為什麼 `RUN cd /app` 不生效？

具體內容如下：

```docker
RUN cd /app
RUN touch hello.txt
```

**結果**：`hello.txt` 會出現在根目錄 `/`，而不是 `/app`。

**原因**：每個 `RUN` 都在一個新的 Shell/容器 環境中執行。`cd` 隻影響當前 `RUN` 的環境。

**解決**：使用 `WORKDIR` 指令。

```docker
WORKDIR /app
RUN touch hello.txt
```

#### Q: 環境變數不生效？

具體內容如下：

```docker
RUN export MY_VAR=hello
RUN echo $MY_VAR
```

**結果**：輸出為空。

**原因**：同上，環境變數只在當前 `RUN` 有效。

**解決**：使用 `ENV` 指令，或在同一行 `RUN` 中匯出。

```docker
ENV MY_VAR=hello
RUN echo $MY_VAR
```

---

### 高階技巧

#### 1. 使用 BuildKit 的掛載快取

BuildKit 支援在 `RUN` 指令中使用 `--mount` 掛載快取，加速建立。

```docker
## 快取 apt 套件

RUN --mount=type=cache,target=/var/cache/apt,sharing=locked \
    --mount=type=cache,target=/var/lib/apt,sharing=locked \
    apt-get update && apt-get install -y gcc
```

```docker
## 快取 Go 模組

RUN --mount=type=cache,target=/go/pkg/mod \
    go build -o app
```

#### 2. 掛載金鑰

安全地使用 SSH 金鑰或 Token，而不將其記錄在映象中。

```docker
RUN --mount=type=secret,id=mysecret \
    cat /run/secrets/mysecret
```

---

### 本章小結

| 要點 | 說明 |
|------|------|
| **作用** | 在新層執行指令 |
| **原則** | 合併指令，清理快取 |
| **格式** | Shell (常用) vs Exec |
| **陷阱** | `cd` 不持久，環境變數不持久 |
| **進階** | 使用 Cache Mount 加速建立 |

### 延伸閱讀

- [CMD 容器啟動指令](cmd.md)：容器啟動時的指令
- [WORKDIR 指定工作目錄](workdir.md)：改變目錄
- [Dockerfile 最佳實踐](../../16_appendix/16.1_best_practices.md)
