## 7.5 ENTRYPOINT 入口點

### 什麼是 ENTRYPOINT

`ENTRYPOINT` 指定容器啟動時執行的入口程式。與 CMD 不同，ENTRYPOINT 定義的指令不會被 `docker run` 的引數覆蓋，而是**接收這些引數**。

> **核心作用**：讓映象像一個可執行程式一樣使用，`docker run` 的引數作為這個程式的引數。

---

### 語法格式

| 格式 | 語法 | 推薦程度 |
|------|------|---------|
| **exec 格式**| `ENTRYPOINT ["可執行檔案", "引數1"]` | ✅**推薦** |
| **shell 格式** | `ENTRYPOINT 指令 引數` | ⚠️ 不推薦 |

```docker
## exec 格式（推薦）

ENTRYPOINT ["nginx", "-g", "daemon off;"]

## shell 格式（不推薦）

ENTRYPOINT nginx -g "daemon off;"
```

---

### ENTRYPOINT vs CMD

#### 核心區別

| 屬性 | ENTRYPOINT | CMD |
|------|------------|-----|
| **定位** | 固定的入口程式 | 預設引數 |
| **docker run 引數** | 追加為引數 | 完全覆蓋 |
| **覆蓋方式** | `--entrypoint` | 直接指定指令 |
| **適用場景** | 把映象當指令用 | 提供預設行為 |

#### 行為對比

具體內容如下：

```docker
## 只用 CMD

CMD ["curl", "-s", "http://example.com"]
```

```bash
$ docker run myimage              # curl -s http://example.com
$ docker run myimage -v           # 執行 -v（錯誤！）
$ docker run myimage curl -v ...  # curl -v ...（完全替換）
```

```docker
## 只用 ENTRYPOINT

ENTRYPOINT ["curl", "-s"]
```

```bash
$ docker run myimage                      # curl -s（缺引數）
$ docker run myimage http://example.com   # curl -s http://example.com ✓
```

```docker
## ENTRYPOINT + CMD 組合（推薦）

ENTRYPOINT ["curl", "-s"]
CMD ["http://example.com"]
```

```bash
$ docker run myimage                      # curl -s http://example.com（預設）
$ docker run myimage http://other.com     # curl -s http://other.com ✓
$ docker run myimage -v http://other.com  # curl -s -v http://other.com ✓
```

---

### 場景一：讓映象像指令一樣使用

#### 需求

建立一個查詢公網 IP 的"指令"映象。

#### 使用 CMD 的問題

具體內容如下：

```docker
FROM ubuntu:24.04
RUN apt-get update && apt-get install -y curl && rm -rf /var/lib/apt/lists/*
CMD ["curl", "-s", "http://myip.ipip.net"]
```

```bash
$ docker run myip           # ✓ 正常工作
當前 IP：61.148.226.66

$ docker run myip -i        # ✗ 錯誤！
exec: "-i": executable file not found
## -i 替換了整個 CMD，被當作可執行檔案

具體內容如下：

```

#### 使用 ENTRYPOINT 解決

具體內容如下：

```docker
FROM ubuntu:24.04
RUN apt-get update && apt-get install -y curl && rm -rf /var/lib/apt/lists/*
ENTRYPOINT ["curl", "-s", "http://myip.ipip.net"]
```

```bash
$ docker run myip           # ✓ 正常工作
當前 IP：61.148.226.66

$ docker run myip -i        # ✓ 新增 -i 引數
HTTP/1.1 200 OK
...
當前 IP：61.148.226.66
```

#### 互動圖示

具體內容如下：

```
ENTRYPOINT ["curl", "-s", "http://myip.ipip.net"]
            │
docker run myip -i
            │
            ▼
curl -s http://myip.ipip.net -i
└─────────────────────────────┘
     ENTRYPOINT + docker run 引數
```

---

### 場景二：啟動前的準備工作

#### 需求

在啟動主服務前執行初始化指令碼（如數據函式庫遷移、許可權設定）。

#### 實現方式

具體內容如下：

```docker
FROM redis:7-alpine
COPY docker-entrypoint.sh /usr/local/bin/
ENTRYPOINT ["docker-entrypoint.sh"]
CMD ["redis-server"]
```

**docker-entrypoint.sh**：

```bash
#!/bin/sh
set -e

## 準備工作

echo "Initializing..."

## 如果第一個引數是 redis-server，以 redis 使用者執行

if [ "$1" = 'redis-server' ]; then
    chown -R redis:redis /data
    exec gosu redis "$@"
fi

## 其他指令直接執行

exec "$@"
```

#### 工作流程

具體內容如下：

```
docker run redis                    docker run redis bash
        │                                    │
        ▼                                    ▼
docker-entrypoint.sh redis-server   docker-entrypoint.sh bash
        │                                    │
        ├─ 初始化                            ├─ 初始化
        ├─ chown -R redis:redis /data        │
        └─ exec gosu redis redis-server      └─ exec bash
           (以 redis 使用者執行)                  (以 root 使用者執行)
```

#### 關鍵點

1. **exec "$@"**：用傳入的引數替換當前程序，確保訊號正確傳遞
2. **條件判斷**：根據 CMD 不同執行不同邏輯
3. **使用者切換**：使用 `gosu` 切換使用者（比 `su` 更適合容器）

---

### 場景三：帶引數的應用

具體內容如下：

```docker
FROM python:3.12-slim
WORKDIR /app
COPY . .
RUN pip install -r requirements.txt

ENTRYPOINT ["python", "app.py"]
CMD ["--host", "0.0.0.0", "--port", "8080"]
```

```bash
## 使用預設引數

$ docker run myapp
## 執行: python app.py --host 0.0.0.0 --port 8080

## 覆蓋引數

$ docker run myapp --host 0.0.0.0 --port 9000
## 執行: python app.py --host 0.0.0.0 --port 9000

## 完全不同的引數

$ docker run myapp --help
## 執行: python app.py --help

具體內容如下：

```

---

### 覆蓋 ENTRYPOINT

使用 `--entrypoint` 引數覆蓋：

```bash
## 正常執行

$ docker run myimage

## 覆蓋 ENTRYPOINT 進入 shell 除錯

$ docker run --entrypoint /bin/sh myimage

## 覆蓋 ENTRYPOINT 並傳入引數

$ docker run --entrypoint /bin/cat myimage /etc/os-release
```

---

### ENTRYPOINT 與 CMD 組合表

| ENTRYPOINT | CMD | 最終執行指令 |
|------------|-----|-------------|
| 無 | 無 | 無（容器無法啟動） |
| 無 | `["cmd", "p1"]` | `cmd p1` |
| `["ep", "p1"]` | 無 | `ep p1` |
| `["ep", "p1"]` | `["cmd", "p2"]` | `ep p1 cmd p2` |
| `ep p1`（shell） | `["cmd", "p2"]` | `/bin/sh -c "ep p1"`（CMD 被忽略） |

> ⚠️ **注意**：shell 格式的 ENTRYPOINT 會忽略 CMD！

---

### 最佳實踐

#### 1. 使用 exec 格式

具體內容如下：

```docker
## ✅ 推薦

ENTRYPOINT ["python", "app.py"]

## ❌ 避免 shell 格式

ENTRYPOINT python app.py
```

#### 2. 提供有意義的預設引數

具體內容如下：

```docker
ENTRYPOINT ["nginx"]
CMD ["-g", "daemon off;"]
```

#### 3. 入口指令碼使用 exec

執行以下指令：

```bash
#!/bin/sh
## 準備工作...

## 使用 exec 替換當前程序

exec "$@"
```

#### 4. 處理訊號

確保 ENTRYPOINT 指令碼能正確傳遞訊號：

```bash
#!/bin/bash
trap 'kill -TERM $PID' TERM INT

## 啟動應用

app "$@" &
PID=$!

## 等待應用退出

wait $PID
```

---

### 本章小結

| ENTRYPOINT | CMD | 適用場景 |
|------------|-----|---------|
| ✓ | ✗ | 映象作為固定指令使用 |
| ✗ | ✓ | 簡單的預設指令 |
| ✓ | ✓ | **推薦**：固定指令 + 可設定引數 |

### 延伸閱讀

- [CMD 容器啟動指令](cmd.md)：預設指令
- [最佳實踐](../../16_appendix/16.1_best_practices.md)：啟動指令設計
- [後台執行](../../05_container/5.2_daemon.md)：前台/後台概念
