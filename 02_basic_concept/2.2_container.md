## 2.2 Docker 容器

容器是 Docker 技術的核心，是應用實際執行的載體。本節將從容器的本質、與虛擬機的區別、儲存層機制以及生命週期管理等方面，全面解析 Docker 容器。

### 一句話理解容器

> **容器是映象的執行實例。如果把映象比作程式，那麼容器就是程序。**用物件導向程式設計的術語來說：**映象是類（Class），容器是物件（Instance）**。

- 一個映象可以建立多個容器
- 每個容器相互獨立，互不影響
- 容器可以被建立、啟動、停止、刪除、暫停

### 容器的本質

> 💡 **筆者認為，理解這一點是理解 Docker 的關鍵****容器的本質是一個特殊的程序。**

```
┌─────────────────────────────────────────────────────────────┐
│                     普通程序                                 │
│  • 與其他程序共享系統資源                                     │
│  • 可以看到其他程序                                          │
│  • 共享網路和檔案系統                                         │
└─────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────┐
│                     容器程序                                 │
│  ┌───────────────────────────────────────────────────────┐ │
│  │  • 有自己的程序空間（看不到宿主機上的其他程序）           │ │
│  │  • 有自己的網路（獨立 IP、連接埠）                         │ │
│  │  • 有自己的檔案系統（獨立的 root 目錄）                  │ │
│  │  • 有自己的使用者（容器內的 root ≠ 宿主機的 root）         │ │
│  └───────────────────────────────────────────────────────┘ │
│     但仍然執行在宿主機的核心上                                │
└─────────────────────────────────────────────────────────────┘
```

這種隔離是透過 Linux 核心的 **Namespace** 技術實現的。

### 容器 vs 虛擬機：核心區別

很多初學者會混淆容器和虛擬機。筆者用一張圖來說明：

```
虛擬機                              容器
┌───────────────────────┐          ┌───────────────────────┐
│   App A    │   App B  │          │   App A    │   App B  │
├────────────┼──────────┤          ├────────────┼──────────┤
│ Guest OS   │ Guest OS │          │ Container  │ Container│
│ (完整系統) │ (完整系統)│          │  (僅應用)   │  (僅應用) │
├────────────┴──────────┤          └────────────┴──────────┤
│      Hypervisor       │          │     Docker Engine     │
├───────────────────────┤          ├───────────────────────┤
│       Host OS         │          │       Host OS         │
├───────────────────────┤          ├───────────────────────┤
│      Hardware         │          │      Hardware         │
└───────────────────────┘          └───────────────────────┘
每個 VM 執行完整 OS                  所有容器共享宿主機核心
```

| 屬性 | 容器 | 虛擬機 |
|------|------|--------|
| **隔離級別** | 程序級（Namespace） | 硬體級（Hypervisor） |
| **啟動時間** | 秒級（甚至毫秒） | 分鐘級 |
| **資源佔用** | MB 級別 | GB 級別 |
| **效能損耗** | 幾乎為零 | 5-20% |
| **核心** | 共享宿主機核心 | 各自獨立核心 |

### 容器的儲存層

理解容器的儲存層機制對於資料的持久化和映象的最佳化至關重要。本節將介紹容器的可寫層以及 Copy-on-Write 機制。

#### 映象層 + 容器層

當容器執行時，Docker 會在映象的只讀層之上建立一個**可寫層**（容器儲存層）：

```
┌─────────────────────────────────────────────┐
│       容器儲存層（可讀寫）                    │ ← 容器執行時建立
│  執行時產生的檔案變化記錄在這裡                │
├─────────────────────────────────────────────┤
│       映象第 N 層（只讀）                     │
├─────────────────────────────────────────────┤
│       映象第 N-1 層（只讀）                   │
├─────────────────────────────────────────────┤
│           ...                               │
├─────────────────────────────────────────────┤
│       映象第 1 層（只讀）                     │ ← 基礎映象層
└─────────────────────────────────────────────┘
```

#### Copy-on-Write（寫時複製）

當容器需要修改映象層中的檔案時：

1. Docker 將該檔案**複製**到容器儲存層
2. 在容器層中進行修改
3. 原始映象層保持不變

```
讀取檔案：直接從映象層讀取（共享，高效）
修改檔案：複製到容器層，然後修改（只有這個容器能看到修改）
```

#### ⚠️ 容器儲存層的生命週期

> **筆者特別強調**：這是新手最容易踩的坑！**容器儲存層與容器生命週期繫結。容器刪除，資料就沒了！**

```bash
## 建立容器，寫入資料

$ docker run -it ubuntu bash
root@abc123:/# echo "important data" > /data.txt
root@abc123:/# exit

## 刪除容器

$ docker rm abc123

## 資料丟了！沒有任何辦法恢復！

```

#### 正確的資料持久化方式

按照 Docker 最佳實踐，容器儲存層應該保持**無狀態**。需要持久化的資料應該使用：

| 方式 | 說明 | 適用場景 |
|------|------|---------|
| **[資料卷（Volume）](../08_data_network/data/volume.md)** | Docker 管理的儲存 | 資料庫、應用資料 |
| **[繫結掛載（Bind Mount）](../08_data_network/data/bind-mounts.md)** | 掛載宿主機目錄 | 開發時共享程式碼 |

```bash
## 使用資料卷（推薦）

$ docker run -v mydata:/var/lib/mysql mysql

## 使用繫結掛載

$ docker run -v /host/path:/container/path nginx
```

這些位置的讀寫**會跳過容器儲存層**，直接寫入宿主機，效能更好，也不會隨容器刪除而丟失。

### 容器的生命週期

掌握容器的生命週期對於管理和除錯 Docker 應用非常重要。下圖展示了容器從建立到刪除的完整狀態流轉。

```
                ┌──────────────────────────────────────────────────┐
                │                  容器生命週期                     │
                └──────────────────────────────────────────────────┘

    docker create           docker start           docker stop
         │                       │                      │
         ▼                       ▼                      ▼
    ┌─────────┐            ┌─────────┐            ┌─────────┐
    │ Created │───────────▶│ Running │───────────▶│ Stopped │
    └─────────┘            └─────────┘            └─────────┘
         │                       │                      │
         │                       │ docker pause         │
         │                       ▼                      │
         │                 ┌─────────┐                  │
         │                 │ Paused  │                  │
         │                 └─────────┘                  │
         │                       │                      │
         │        docker rm      │     docker rm        │
         └───────────────────────┴──────────────────────┘
                                 │
                                 ▼
                           ┌──────────┐
                           │ Deleted  │
                           └──────────┘
```

#### 常用生命週期指令

執行以下指令：

```bash
## 建立並啟動容器（最常用）

$ docker run nginx

## 分步操作

$ docker create nginx    # 建立容器（不啟動）
$ docker start abc123    # 啟動容器

## 停止容器

$ docker stop abc123     # 優雅停止（傳送 SIGTERM，等待後傳送 SIGKILL）
$ docker kill abc123     # 強制停止（直接傳送 SIGKILL）

## 暫停/恢復（不常用，但有時有用）

$ docker pause abc123    # 暫停容器內所有程序
$ docker unpause abc123  # 恢復

## 刪除容器

$ docker rm abc123       # 刪除已停止的容器
$ docker rm -f abc123    # 強制刪除執行中的容器
```

### 容器與程序的關係

> **核心概念**：容器的生命週期 = 主程序（PID 1）的生命週期

```bash
## 主程序執行，容器執行

## 主程序退出，容器停止

```

這就是為什麼：

```bash
## 這個容器會立即退出（bash 沒有輸入就退出了）

$ docker run ubuntu

## 這個容器會持續執行（nginx 作為守護程序持續執行）

$ docker run nginx
```

詳細解釋請參考[後台執行](../05_container/5.2_daemon.md)章節。

### 容器的隔離性

Docker 容器透過以下 Namespace 實現隔離：

| Namespace | 隔離內容 | 效果 |
|-----------|---------|------|
| **PID** | 程序 ID | 容器內 PID 1 是應用程序，看不到宿主機其他程序 |
| **NET** | 網路 | 獨立的網路棧、IP 地址、連接埠 |
| **MNT** | 檔案系統 | 獨立的根目錄和掛載點 |
| **UTS** | 主機名 | 獨立的主機名和網域名稱 |
| **IPC** | 程序間通訊 | 獨立的訊號量、訊息佇列 |
| **USER** | 使用者 | 獨立的使用者和組 ID |

> 想深入瞭解？請閱讀[底層實現 - 命名空間](../14_implementation/14.2_namespace.md)。

### 本章小結

| 概念 | 要點 |
|------|------|
| **容器是什麼** | 映象的執行實例，本質是隔離的程序 |
| **容器 vs 虛擬機** | 共享核心，更輕量，但隔離性較弱 |
| **儲存層** | 可寫層隨容器刪除而消失 |
| **資料持久化** | 使用 Volume 或 Bind Mount |
| **生命週期** | 與主程序（PID 1）繫結 |

理解了映象和容器，接下來讓我們學習[倉庫](2.3_repository.md)——儲存和分發映象的服務。

### 延伸閱讀

- [啟動容器](../05_container/5.1_run.md)：詳細的容器啟動選項
- [後台執行](../05_container/5.2_daemon.md)：理解容器為什麼會"立即退出"
- [進入容器](../05_container/5.4_attach_exec.md)：如何操作執行中的容器
- [資料管理](../08_data_network/README.md)：Volume 和數據持久化詳解
